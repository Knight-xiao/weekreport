
### 奖励函数设置
参考`robosuite`中的基准环境，学习其中奖励函数设置。

`TwoArmTransport`:
这里用的是稀疏奖励：当有效载荷（payload）在目标箱子中且垃圾（trash）在垃圾桶中时，奖励值为1.0具体到任务场景中就是，当锤子放到了目标箱子中且原本放在目标箱子里的红色物体在其他箱子里时，奖励值为1，否则为0

`TwoArmHandOver`:
这个任务使用两个机械臂(Arm0和Arm1)抓取并操控一个物体（锤子把手），任务的核心目标是让两个机械臂共同协作，任务步骤和对应奖励如下：
- Arm0到达目标位置：要求Arm0接近锤子把手，奖励值为`1-tan(10*distance)`
- Arm0抓取锤子把手，奖励值为0.5
- Arm0举起锤子（要求超过一定高度阈值），奖励值为1.0
- Arm0保持悬停，此时的奖励值由Arm0和Arm1之间距离决定
- 双臂抓取：如果两个臂都在抓取锤子，奖励值为1.5
- Arm1抓取：只有Arm1抓取锤子，即交换完成，奖励值为2.0

PS：对于transport任务，应该是上述两个任务的结合体，后者实现了交换过程，前者则是交换之后还要把锤子放到指定的目标箱子里。

`TwoArmPegInHole`：
这是一个插入任务，目标是将销钉正确的放入孔中，奖励函数设置如下：
- 距离奖励：基于销钉和孔之间的距离，计算公式和上述距离奖励同上所述
- 姿态奖励：基于销钉和孔的对齐度计算，鼓励销钉朝孔的正确位置对齐，会计算销钉与孔的法向量之间的夹角余弦值

`Lift`：
这个任务是单臂机器人抓取桌面上的物体并举起，奖励函数设置如下：
- 到达奖励（Reaching Reward）：鼓励机械臂接近立方体。奖励值为`1-tan(10*distance)`
- 抓取奖励（Grasping Reward）：如果机械臂抓取立方体，奖励值为0.25
- 举起奖励（Lifting Reward）：如果机械臂举起立方体，奖励值为1.0

`wipe`:
这是一个单臂机器人擦拭清洁的任务，任务的目标是清洁一个表面，将上面的一些标记擦拭掉。奖励函数综合考虑了机器人操作的各种因素，包括是否与物体发生碰撞、是否超出了关节限制、擦拭工具的接触情况以及是否成功清洁表面：
- 目标移动奖励：根据擦拭工具与脏点之间的距离来计算奖励，鼓励机器人逐步接近脏点。计算使用了np.tanh平滑函数，以减少距离对奖励的影响，并鼓励机器人逐步擦拭
- 擦拭接触奖励：如果擦拭工具与表面接触，给予self.wipe_contact_reward奖励
- 擦拭标记奖励：每次擦拭掉一个标记时，奖励增加self.unit_wiped_reward
- 压力惩罚：如果机器人施加的力超过最大压力阈值self.pressure_threshold_max，则施加惩罚 self.excess_force_penalty_mul * total_force_ee
- 加速度惩罚：如果机器人末端执行器的加速度过大，施加加速度惩罚self.ee_accel_penalty，鼓励平稳的操作

### 任务场景构建
目前设计了一个操作任务场景：由于目标卫星需要观测并记录太空环境，需要安装相机，机器人卫星需要捕获目标卫星并执行安装操作（或者说目标卫星本来就有相机，但由于太空辐射或其他原因导致相机损坏，需要进行更换，要求机器人卫星执行更换操作任务，总而言之，就是设计一个相对合理且符合背景的任务场景）

在搭建任务场景时，发现需要进行碰撞设置（以前都是规划操作，没意识到碰撞测试）。在 MuJoCo 中，通过调整contype和conaffinity可以实现模型之间的碰撞控制。
- `contype`：碰撞体的“发出”属性，用来标记几何体可以触发哪些碰撞检测。
- `conaffinity`：碰撞体的“接收”属性，用来标记几何体可以与哪些其他几何体发生碰撞。
每个值用二进制位表示，设置时使用整数。通过位运算，contype 和 conaffinity 的交集决定是否检测碰撞。经过实际测试，`contype=1 conaffinity=0`这组搭配效果最好。
PS：查看了一些其他项目使用的模型，有的没有对上述两个属性进行修改，而是使用`<contact>`下的`<pair>`属性，`<pair>`属性用于手动定义两两几何体之间的碰撞，形式如下所示：
```
<contact>
    <pair geom1="robot_arm" geom2="object" condim="3" gap="0.01" friction="1.0 0.5 0.5"/>
</contact>
```

